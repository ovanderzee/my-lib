{"version":3,"file":"myLib.js","sources":["../src/number/isUsableNumber.ts","../src/string/isCharType.ts","../src/math/round.ts","../src/type/isWrappedPrimitive.ts","../src/math/groupProperties.ts","../src/type/isFundamental.ts","../src/object/deepClone.ts","../src/string/stringify.ts","../src/array/arrayCombination.ts","../src/string/arrayFromCommaSeparatedList.ts","../src/dom/arrayFromQuery.ts","../src/array/arrayIntersection.ts","../src/console/greet.ts","../src/object/hasOwnProperty.ts","../src/string/isStringType.ts","../src/dom/isAttachedToDom.ts","../src/number/isEqualSigns.ts","../src/regex/isExactMatch.ts","../src/type/isPrimitive.ts"],"sourcesContent":["/**\n * Test for values with which calculations can be done\n * @param {Arguments} nums - one or more numeric values to test\n * @returns {boolean} every argument is a usable number\n */\nconst isUsableNumber = function (...nums: number[]): boolean {\n    let isUsable = Boolean(nums.length)\n    const numbers = Array.from(nums)\n    numbers.forEach((value) => {\n        isUsable =\n            isUsable && typeof value === 'number' && Number.isFinite(value)\n    })\n    return isUsable\n}\n\nexport { isUsableNumber }\n","/**\n * Test value for being a character; a string with a length of one\n * @param {string} char\n * @returns {boolean} is a single character\n */\nconst isChar = (char: string): boolean => {\n    return Boolean(char && typeof char === 'string' && char.length === 1)\n}\n\n/**\n * Test value for being a string representation of a digit\n * @param {string} char\n * @returns {boolean} is a number 0-9\n */\nconst isDigit = (char: string): boolean => {\n    return isChar(char) && Boolean(char.match(/[0-9]/))\n}\n\n/**\n * Test value for being a letter\n * @param {string} char\n * @returns {boolean} char is a letter\n */\nconst isLetter = (char: string): boolean => {\n    return isChar(char) && char.toLowerCase() !== char.toUpperCase()\n}\n\n/**\n * Test value for being a lowercase letter\n * @param {string} char\n * @returns {boolean} char is a lower-case letter\n */\nconst isLower = (char: string): boolean => {\n    return (\n        isChar(char) &&\n        char === char.toLowerCase() &&\n        char !== char.toUpperCase()\n    )\n}\n\n/**\n * Test value for being an uppercase letter\n * @param {string} char\n * @returns {boolean} char is a upper-case letter\n */\nconst isUpper = (char: string): boolean => {\n    return (\n        isChar(char) &&\n        char === char.toUpperCase() &&\n        char !== char.toLowerCase()\n    )\n}\n\nexport { isChar, isDigit, isLetter, isLower, isUpper }\n","/**\n * Round at decimals\n * @param {number} origin - any number to round\n * @param {number} decimals - number of decimals to round at\n * @returns {number} the rounded number\n */\nconst roundAtDecimals = function (origin: number, decimals: number): number {\n    // when the returned value would be 0.000...00\n    /* @ts-ignore */\n    if (origin < 1 + 'e-' + decimals && origin > -1 + 'e-' + decimals) {\n        return 0\n    }\n    // https://www.jacklmoore.com/notes/rounding-in-javascript/\n    /* @ts-ignore */\n    return Number(Math.round(origin + 'e' + decimals) + 'e-' + decimals)\n}\n\n/**\n * Round at digits to exponential notation; round with significance\n * @param {number} origin - any number to round\n * @param {number} digits - number of significant digits to round at\n * @returns {string} the rounded number as exponent\n */\nconst roundAtDigitsExponent = function (\n    origin: number,\n    digits: number,\n): string {\n    if (isNaN(origin) || !Number.isInteger(digits) || digits < 1) return 'NaN'\n\n    const absolute = Math.abs(origin)\n    if (absolute === 0) return '0'\n    if (absolute === Infinity) return String(origin)\n\n    const exponent = Math.floor(Math.log(absolute) / Math.log(10))\n    const coefficient = origin / Math.pow(10, exponent)\n    const rounded = roundAtDecimals(coefficient, digits - 1)\n\n    return rounded + 'e' + exponent\n}\n\n/**\n * Round at digits; round with significance\n * @param {number} origin - any number to round\n * @param {number} digits - number of significant digits to round at\n * @returns {number} the rounded number\n */\nconst roundAtDigits = function (origin: number, digits: number): number {\n    const expString = roundAtDigitsExponent(origin, digits)\n    return Number(expString)\n}\n\nexport { roundAtDecimals, roundAtDigitsExponent, roundAtDigits }\n","/**\n * Check the variable for living in an object wrapper\n * These can be generated by new String / Number etc.\n * see https://developer.mozilla.org/en-US/docs/Glossary/Primitive\n * @param {unknown} value - unknown value to check\n * @returns {boolean} is a wrapped primitive\n */\nconst isWrappedPrimitive = function (value: unknown): boolean {\n    const result =\n        typeof value === 'object' &&\n        (value instanceof String ||\n            value instanceof Number ||\n            value instanceof BigInt ||\n            value instanceof Boolean ||\n            value instanceof Symbol)\n\n    return result\n}\n\nexport { isWrappedPrimitive }\n","/**\n * Calculate sum of array with Numbers\n * @param {number[]} seq - array containing numbers\n * @return {number} the sum of the numbers\n */\nconst mathSum = (seq: number[]): number => seq.reduce((a, b) => a + b, 0)\n\n/**\n * Calculate average of array with Numbers\n * @param {number[]} seq - array containing numbers\n * @return {number} the average of the numbers\n */\nconst mathAvg = (seq: number[]): number => mathSum(seq) / seq.length || 0\n\nexport { mathSum, mathAvg }\n","import { isWrappedPrimitive } from './isWrappedPrimitive'\n\n/**\n * Check value for indivisible:\n * string, number, boolean, bigint, symbol, undefined, null, function\n * @param {unknown} value - unknown value to test\n * @returns {boolean}\n */\nconst isFundamental = function (value: unknown): boolean {\n    // in general, not an object\n    let result = typeof value !== 'object'\n    // but include null and 'newed' primitives\n    result = result || value === null || isWrappedPrimitive(value)\n    return result\n}\n\nexport { isFundamental }\n","import { isFundamental } from '../type/isFundamental'\n\n/**\n * Recursively copy all indivisible data to new object\n * Pay attention to Date and RegExp objects\n * @param {any} variable - any value to check\n * @returns {any} the same data with different references\n */\nconst deepClone = function (variable: any): any {\n    let product = variable\n    if (isFundamental(variable)) {\n        return variable\n    } else if (Array.isArray(variable)) {\n        product = []\n        for (const value of variable) {\n            product.push(deepClone(value))\n        }\n    } else if (variable instanceof Date) {\n        product = new Date(variable.getTime())\n    } else if (variable instanceof RegExp) {\n        product = new RegExp(variable.source, variable.flags)\n    } else if (typeof variable === 'object') {\n        product = {}\n        for (const [key, value] of Object.entries(variable)) {\n            product[key] = deepClone(value)\n        }\n    }\n\n    return product\n}\n\nexport { deepClone }\n","/**\n * Helper function to produce a string, an empty string if necessary\n * @private\n * @param {unknown} value\n * @return {String} string represention of anything\n */\nconst finalStringify = function (value: unknown): string {\n    try {\n        return JSON.stringify(value)\n    } catch (e) {\n        return ''\n    }\n}\n\n/**\n * Try generic ways to produce a string, an empty string if necessary\n * @param {any} value\n * @return {String} string represention of anything\n */\nconst forceStringify = function (value: any): string {\n    let result\n    try {\n        // first coerce to string for the sake of undefined\n        result = String(value)\n        if (result === '[object Object]') {\n            result = finalStringify(value)\n        }\n        return result\n    } catch (e) {\n        return finalStringify(value)\n    }\n}\n\n/**\n * Convert anything to a string, an empty string if necessary.\n * Expect sensible but not consistent cross-environment behaviour on functions.\n * @param {any} value\n * @return {String} string represention of anything\n */\nconst stringify = function (value: any): string {\n    let result\n    try {\n        result = value.toString()\n        if (result === '[object Object]') {\n            result = forceStringify(value)\n        }\n        return result\n    } catch (e) {\n        return forceStringify(value)\n    }\n}\n\nexport { forceStringify, stringify }\n","/**\n * Find unique values from both arrays\n * @param {Array} array1\n * @param {Array} array2\n * @return {Array} the combination\n */\nconst arrayCombination = function (\n    array1: unknown[],\n    array2: unknown[],\n): unknown[] {\n    const concatination = [...array1, ...array2]\n    const unification = new Set(concatination)\n    return Array.from(unification)\n}\n\nexport { arrayCombination }\n","/**\n * Process comma separated list to a sanitised array with normalised strings\n * @param {string} commaSeperatedList\n * @returns {string[]} array with separate strings\n */\nconst arrayFromCommaSeparatedList = function (\n    commaSeparatedList: string,\n): string[] {\n    const list = commaSeparatedList.split(',')\n    // normalise\n    const trimmed = list.map((item) => item.trim().replace(/\\s+/g, ' '))\n    // sanitise\n    return trimmed.filter((item) => {\n        return item.length\n    })\n}\n\nexport { arrayFromCommaSeparatedList }\n","/**\n * Create a genuine array from a css-query\n * @param {string} cssQuery\n * @returns {Node[]} array with Elements\n */\nconst arrayFromQuery = function (cssQuery: string): Node[] {\n    // the push.apply operation is in most browsers among the fastest\n    // https://jsperf.com/nodelist-to-array/27\n    const elementArray: Node[] = []\n    const nodeList: NodeListOf<Node> = document.querySelectorAll(cssQuery)\n    elementArray.push(...Array.from(nodeList))\n    return elementArray\n}\n\nexport { arrayFromQuery }\n","/**\n * Find unique values appearing in both arrays\n * @param {Array} array1\n * @param {Array} array2\n * @return {Array} the intersection\n */\nconst arrayIntersection = function (array1: any[], array2: any[]): unknown[] {\n    const lookup: Record<string, number> = {}\n    array1.forEach((member) => (lookup[member] = 1))\n    return array2.filter((member) => {\n        if (lookup[member] === 1) {\n            delete lookup[member]\n            return member\n        }\n    })\n}\n\nexport { arrayIntersection }\n","/**\n * The sake of package; log the console\n */\nconst greet = (): void => {\n    // The epic proof of getting through\n    console.log('Hello World!')\n}\n\nexport { greet }\n\n/*\nrespecting the functionality of my predecessor\ndependents on npm\ndependents on github\n*/\n","/**\n * Check for existence of property in object\n * @param {object} object\n * @param {string} prop\n * @returns {boolean} the object has the property as its own property -- not inheriting it\n */\nconst hasOwnProperty = function (\n    object: Record<string, unknown>,\n    prop: string,\n): boolean {\n    const hasIt = Object.prototype.hasOwnProperty.call(object, prop)\n    return hasIt\n}\n\nexport { hasOwnProperty }\n","import { isDigit, isLetter } from './isCharType'\n\n/**\n * Test for being a string consisting of letters and/or digits,\n * for being undelimited\n * @param {string} word\n * @returns {boolean} consists of letters and/or digits only\n */\nconst isAlphaNumeric = (word: string): boolean => {\n    return Boolean(\n        word &&\n            word.split &&\n            !word.split('').some((char) => !(isLetter(char) || isDigit(char))),\n    )\n}\n\nexport { isAlphaNumeric }\n","/**\n * Check node for being part of the DOM\n * @param {Node} node\n * @returns {boolean} true when the node is on the webpage\n */\nconst isAttachedToDom = function (elm: Element): boolean {\n    return (\n        elm &&\n        (elm.getRootNode() instanceof Document ||\n            elm.getRootNode() instanceof ShadowRoot)\n    )\n}\n\nexport { isAttachedToDom }\n","/**\n * Check all arguments for being a number with the same sign\n * (Zero is sign-neutral)\n * @param {Arguments} nums - numeric arguments\n * @return {boolean} equality\n */\nconst isEqualSigns = function (...nums: number[]): boolean {\n    const positives: number[] = [...nums].filter((arg) => arg >= 0)\n    const negatives: number[] = [...nums].filter((arg) => arg <= 0)\n    return positives.length === nums.length || negatives.length === nums.length\n}\n\nexport { isEqualSigns }\n","/**\n * Check for a match covering the string entirely\n * @param {string} word\n * @param {RegExp} regex\n * @returns {boolean} all characters of the word were described in regex\n */\nconst isExactMatch = (word: string, regex: RegExp): boolean => {\n    const match = word.match(regex)\n    const result = match && match[0] === word\n    return Boolean(result)\n}\n\nexport { isExactMatch }\n","import { isWrappedPrimitive } from './isWrappedPrimitive'\n\n/**\n * Check value for being a primitive\n * but leave out the anti-value undefined;\n * @param {unknown} value - unknown value to check\n * @returns {boolean} is a primitive\n */\nconst isPrimitive = function (value: unknown): boolean {\n    const typePrimitive =\n        typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean' ||\n        typeof value === 'bigint' ||\n        typeof value === 'symbol'\n\n    return isWrappedPrimitive(value) || typePrimitive\n}\n\nexport { isPrimitive }\n"],"names":["isChar","char","Boolean","length","isDigit","match","isLetter","toLowerCase","toUpperCase","roundAtDecimals","origin","decimals","Number","Math","round","isWrappedPrimitive","value","String","BigInt","Symbol","mathSum","seq","reduce","a","b","isFundamental","result","deepClone","variable","product","Array","isArray","push","Date","getTime","RegExp","source","flags","key","Object","entries","finalStringify","JSON","stringify","e","forceStringify","array1","array2","concatination","unification","Set","from","commaSeparatedList","split","map","item","trim","replace","filter","cssQuery","elementArray","nodeList","document","querySelectorAll","lookup","forEach","member","console","log","object","prop","prototype","hasOwnProperty","call","word","some","elm","getRootNode","Document","ShadowRoot","nums","positives","arg","negatives","regex","typePrimitive","isUsable","isFinite","digits","expString","isNaN","isInteger","absolute","abs","Infinity","exponent","floor","coefficient","pow","roundAtDigitsExponent","toString"],"mappings":"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"}
{"version":3,"file":"myLib.js","sources":["../src/number/isUsableNumber.js","../src/string/isCharType.js","../src/string/isStringType.js","../src/regex/isExactMatch.js","../src/math/round.js","../src/type/isPrimitive.js","../src/dom/isAttachedToDom.js"],"sourcesContent":["/**\n * Test for values with which calculations can be done\n * @param {Arguments} anonymus - one or more values to test\n * @returns {boolean} every argument is a useable number\n */\nconst isUsableNumber = function () {\n    let isUsable = Boolean(arguments.length)\n    Array.from(arguments).forEach((value) => {\n        isUsable =\n            isUsable && typeof value === 'number' && Number.isFinite(value)\n    })\n    return isUsable\n}\n\nexport { isUsableNumber }\n","/**\n * Test value for being a character; a string with a length of one\n * @param {string} char\n * @returns {boolean} is a single character\n */\nconst isChar = (char) => {\n    return Boolean(char && typeof char === 'string' && char.length === 1)\n}\n\n/**\n * Test value for being a string representation of a digit\n * @param {string} char\n * @returns {boolean} is a number 0-9\n */\nconst isDigit = (char) => {\n    return isChar(char) && Boolean(char.match(/[0-9]/))\n}\n\n/**\n * Test value for being a letter\n * @param {string} char\n * @returns {boolean} char is a letter\n */\nconst isLetter = (char) => {\n    return isChar(char) && char.toLowerCase() !== char.toUpperCase()\n}\n\n/**\n * Test value for being a lowercase letter\n * @param {string} char\n * @returns {boolean} char is a lower-case letter\n */\nconst isLower = (char) => {\n    return (\n        isChar(char) &&\n        char === char.toLowerCase() &&\n        char !== char.toUpperCase()\n    )\n}\n\n/**\n * Test value for being an uppercase letter\n * @param {string} char\n * @returns {boolean} char is a upper-case letter\n */\nconst isUpper = (char) => {\n    return (\n        isChar(char) &&\n        char === char.toUpperCase() &&\n        char !== char.toLowerCase()\n    )\n}\n\nexport { isChar, isDigit, isLetter, isLower, isUpper }\n","import { isDigit, isLetter } from './isCharType'\n\n/**\n * Test for being a string consisting of letters and/or digits\n * @param {string} word\n * @returns {boolean} consists of letters and/or digits only\n */\nconst isAlphaNumeric = (word) => {\n    return (\n        word &&\n        word.split &&\n        !word.split('').some((char) => {\n            return !(isLetter(char) || isDigit(char))\n        })\n    )\n}\n\nexport { isAlphaNumeric }\n","/**\n * Check for a match covering the string entirely\n * @param {string} word\n * @param {RegExp} regex\n * @returns {boolean}\n */\nconst isExactMatch = (word, regex) => {\n    const match = word.match(regex)\n    const result = match && match[0] === word\n    return result\n}\n\nexport { isExactMatch }\n","/**\n * Round at decimals\n * @param {number} origin - any number to round\n * @param {number} decimals - number of decimals to round at\n * @returns {number} the rounded number\n */\nconst roundAtDecimals = function (origin, decimals) {\n    if (origin < 1 + 'e-' + decimals && origin > -1 + 'e-' + decimals) {\n        return 0\n    }\n    // https://www.jacklmoore.com/notes/rounding-in-javascript/\n    return Number(Math.round(origin + 'e' + decimals) + 'e-' + decimals)\n}\n\n/**\n * Round at digits; round with significance\n * @param {number} origin - any number to round\n * @param {number} digits - number of significant digits to round at\n * @returns {number} the rounded number\n */\nconst roundAtDigits = function (origin, digits) {\n    const exponent = Math.floor(Math.log(Math.abs(origin)) / Math.log(10))\n    const coefficient = origin / Math.pow(10, exponent)\n    const rounded = roundAtDecimals(coefficient, digits - 1)\n\n    return Number(rounded + 'e' + exponent)\n}\n\nexport { roundAtDecimals, roundAtDigits }\n","/**\n * Check value for being a primitive\n * @param {any} value - any value to check\n * @returns {boolean} is a primitive\n */\nconst isPrimitive = function (value) {\n    return (\n        typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'boolean'\n    )\n}\n\nexport { isPrimitive }\n","/**\n * Check node for being part of the DOM\n * @param {Node} node\n * @returns {boolean} true when the node is on the webpage\n */\nconst isAttachedToDom = function (elm) {\n    return (\n        elm &&\n        (elm.getRootNode() instanceof Document ||\n            elm.getRootNode() instanceof ShadowRoot)\n    )\n}\n\nexport { isAttachedToDom }\n"],"names":["isUsableNumber","isUsable","Boolean","arguments","length","Array","from","forEach","value","Number","isFinite","isChar","char","isDigit","match","isLetter","toLowerCase","toUpperCase","isLower","isUpper","isAlphaNumeric","word","split","some","isExactMatch","regex","roundAtDecimals","origin","decimals","Math","round","roundAtDigits","digits","exponent","floor","log","abs","coefficient","pow","rounded","isPrimitive","isAttachedToDom","elm","getRootNode","Document","ShadowRoot"],"mappings":"AAKK,MAACA,EAAiB,WACnB,IAAIC,EAAWC,QAAQC,UAAUC,QAKjC,OAJAC,MAAMC,KAAKH,WAAWI,QAASC,IAC3BP,EACIA,GAA6B,iBAAVO,GAAsBC,OAAOC,SAASF,KAE1DP,GCNLU,EAAUC,GACLV,QAAQU,GAAwB,iBAATA,GAAqC,IAAhBA,EAAKR,QAQtDS,EAAWD,GACND,EAAOC,IAASV,QAAQU,EAAKE,MAAM,UAQxCC,EAAYH,GACPD,EAAOC,IAASA,EAAKI,gBAAkBJ,EAAKK,cAQjDC,EAAWN,GAETD,EAAOC,IACPA,IAASA,EAAKI,eACdJ,IAASA,EAAKK,cAShBE,EAAWP,GAETD,EAAOC,IACPA,IAASA,EAAKK,eACdL,IAASA,EAAKI,cC1ChBI,EAAkBC,GAEhBA,GACAA,EAAKC,QACJD,EAAKC,MAAM,IAAIC,KAAMX,KACTG,EAASH,IAASC,EAAQD,KCNzCY,EAAe,CAACH,EAAMI,KACxB,MAAMX,EAAQO,EAAKP,MAAMW,GAEzB,OADeX,GAASA,EAAM,KAAOO,GCFnCK,EAAkB,SAAUC,EAAQC,GACtC,OAAID,EAAS,MAAWC,GAAYD,EAAS,OAAYC,EAC9C,EAGJnB,OAAOoB,KAAKC,MAAMH,EAAS,IAAMC,GAAY,KAAOA,IASzDG,EAAgB,SAAUJ,EAAQK,GACpC,MAAMC,EAAWJ,KAAKK,MAAML,KAAKM,IAAIN,KAAKO,IAAIT,IAAWE,KAAKM,IAAI,KAC5DE,EAAcV,EAASE,KAAKS,IAAI,GAAIL,GACpCM,EAAUb,EAAgBW,EAAaL,EAAS,GAEtD,OAAOvB,OAAO8B,EAAU,IAAMN,ICpB5BO,EAAc,SAAUhC,GAC1B,MACqB,iBAAVA,GACU,iBAAVA,GACU,kBAAVA,GCJTiC,EAAkB,SAAUC,GAC9B,OACIA,IACCA,EAAIC,wBAAyBC,UAC1BF,EAAIC,wBAAyBE"}